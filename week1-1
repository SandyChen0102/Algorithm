#include <iostream>
#include <list>
#include <unordered_map>

using namespace std;

class LRUCache {
public:
    LRUCache(int capacity) {
        this->size = capacity;
    }

    int get(int key) {
        if (cacheRecord.find(key) == cacheRecord.end()) {
            return -1;
        }

        // 把這個 key 移動到 LRU 頭部
        cache.splice(cache.begin(), cache, cacheRecord[key]);
        return cache.begin()->second;
    }

    void put(int key, int value) {
        if (cacheRecord.find(key) != cacheRecord.end()) {
            // 更新值並移動到頭部
            cacheRecord[key]->second = value;
            cache.splice(cache.begin(), cache, cacheRecord[key]);
        } else {
            if (cache.size() == size) {
                // 移除 LRU（最久未使用的）元素
                int lruKey = cache.back().first;
                cacheRecord.erase(lruKey);
                cache.pop_back();
            }
            // 插入新元素
            cache.push_front({key, value});
            cacheRecord[key] = cache.begin();
        }
    }

private:
    int size;
    list<pair<int, int>> cache;  // 雙向鏈表，儲存 {key, value}
    unordered_map<int, list<pair<int, int>>::iterator> cacheRecord; // 快速查找 key 在鏈表中的位置
};

// 測試函式
void runExample() {
    LRUCache lRUCache(2);
    lRUCache.put(1, 1); // cache is {1=1}
    lRUCache.put(2, 2); // cache is {1=1, 2=2}
    cout << lRUCache.get(1) << endl;    // return 1
    lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
    cout << lRUCache.get(2) << endl;    // returns -1 (not found)
    lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
    cout << lRUCache.get(1) << endl;    // return -1 (not found)
    cout << lRUCache.get(3) << endl;    // return 3
    cout << lRUCache.get(4) << endl;    // return 4
}

int main() {
    runExample();
    return 0;
}
